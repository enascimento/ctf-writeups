//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t function_80482f4(void);
void function_8048320(void);
int32_t function_80483c0(void);
int32_t function_80483d0(int32_t a1);
int32_t function_8048400(int32_t a1, int32_t a2);
int32_t function_804848b(int32_t a1, char * a2, char * a3, int32_t a4);
int32_t function_8048539(int32_t * a1, char * a2, int32_t a3);
int32_t function_8048607(int32_t * a1, int32_t a2);
void function_80486a4(void);
int32_t function_80486f0(int32_t a1);
int32_t function_804873e(int32_t a1, int32_t * a2);
int32_t function_8048800(int32_t a1, int32_t a2, int32_t a3);
void function_8048861(void);
void function_8048874(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // edx
int32_t g5 = 0; // esi
char (*g6)[28] = "yuoteavpxqgrlsdhwfjkzi_cmbn"; // 0x8049c0c
char g7 = 0; // 0x8049c10

// ------------------------ Functions -------------------------

// Address range: 0x80482f4 - 0x8048316
int32_t function_80482f4(void) {
    int32_t result = *(int32_t *)(function_80483c0() + 0x18df); // 0x8048303
    if (result != 0) {
        // 0x804830d
        __gmon_start();
        // branch -> 0x8048312
    }
    // 0x8048312
    int32_t v1;
    g3 = v1;
    return result;
}

// Address range: 0x8048320 - 0x804838f
void function_8048320(void) {
    // 0x8048320
    return;
}

// Address range: 0x8048390 - 0x80483bf
int32_t entry_point(int32_t a1, int32_t a2) {
    int32_t v1;
    g5 = v1;
    int32_t result = __libc_start_main((int32_t * (*)(int32_t, char **, char **))function_804873e, v1, (char **)&a1, (void (**)())function_8048800, (void (**)())0x8048870, (void (**)())g4); // 0x80483ac
    g1 = result;
    return result;
}

// Address range: 0x80483c0 - 0x80483cf
int32_t function_80483c0(void) {
    // 0x80483c0
    int32_t result;
    return result;
}

// Address range: 0x80483d0 - 0x80483ff
int32_t function_80483d0(int32_t a1) {
    // 0x80483d0
    return 3;
}

// Address range: 0x8048400 - 0x804848a
int32_t function_8048400(int32_t a1, int32_t a2) {
    // 0x8048400
    g1 = (int32_t)(((int32_t)(char)&g7 - 0x8049c10 >> 2) + ((int32_t)(char)&g7 - 0x8049c10 >> 2) / 0x80000000) >> 1;
    if ((((int32_t)(char)&g7 - 0x8049c10 >> 2) + ((int32_t)(char)&g7 - 0x8049c10 >> 2) / 0x80000000 & 1) != 0) {
        // 0x8048418
        // branch -> 0x8048433
    }
    // 0x8048433
    return ((int32_t)(char)&g7 - 0x8049c10 >> 2) + ((int32_t)(char)&g7 - 0x8049c10 >> 2) / 0x80000000 >> 1;
}

// Address range: 0x804848b - 0x8048538
int32_t function_804848b(int32_t a1, char * a2, char * a3, int32_t a4) {
    // 0x804848b
    if (a1 == 0 || a2 == NULL || a3 == NULL) {
        // 0x8048537
        return 0;
    }
    // 0x80484ad
    if (*a2 != 0) {
        char * v1 = a3;
        char * v2 = a2;
        int32_t v3 = 1; // 0x80485311927
        // branch -> 0x804850c
      lab_0x804850c:
        while (true) {
            char * v4 = v1;
            char * v5 = v2;
            int32_t v6 = v3;
            if (*v1 == 0) {
              lab_0x8048516:
                // 0x8048516
                // branch -> 0x8048516
                // 0x8048516
                // branch -> 0x8048537
                // 0x8048537
                return (int32_t)((*v4 | *v5) == 0) & v6;
            }
            int32_t v7 = function_8048539((int32_t *)a1, v2, (int32_t)*v1); // 0x80484d5
            char * v8 = v2;
            // branch -> 0x80484ea
            while (true) {
                int32_t v9 = (int32_t)v8;
                if (*v8 != 76) {
                    // 0x80484f4
                    if (*v8 != 82) {
                        int32_t v10 = v7 & v3; // 0x80484dd
                        char * v11 = (char *)((int32_t)v1 + 1);
                        char * v12 = (char *)(v9 + 1);
                        if (*v12 == 0) {
                            v4 = v11;
                            v5 = v12;
                            v6 = v10;
                            // break (via goto) -> 0x8048516
                            goto lab_0x8048516;
                        }
                        v1 = v11;
                        v2 = v12;
                        v3 = v10;
                        // continue (via goto) -> 0x804850c
                        goto lab_0x804850c;
                    }
                }
                // 0x80484e6
                v8 = (char *)(v9 + 1);
                // branch -> 0x80484ea
            }
            char * v13 = v4;
            char * v14 = v5;
            int32_t v15 = v6;
            // branch -> 0x8048516
            char v16 = *v14; // 0x8048519
            char v17 = *v13; // 0x8048524
            int32_t v18 = (int32_t)((v17 | v16) == 0) & v15; // 0x8048531
            int32_t result = v18;
            // branch -> 0x8048537
            // 0x8048537
            return result;
        }
    }
    // 0x8048516
    // branch -> 0x8048537
    // 0x8048537
    return (int32_t)((*a3 | *a2) == 0) & 1;
}

// Address range: 0x8048539 - 0x8048606
int32_t function_8048539(int32_t * a1, char * a2, int32_t a3) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = 0x1000000 * a3 / 0x1000000; // 0x8048542_0
    if (a1 == NULL) {
        // 0x8048555
        // branch -> 0x8048605
        // 0x8048605
        return 0;
    }
    int32_t v3 = (int32_t)a2;
    if (*a2 == 0) {
        // 0x8048555
        // branch -> 0x8048605
        // 0x8048605
        return 0;
    }
    char * v4 = (char *)(v1 + 8); // 0x8048562_0
    int32_t result; // 0x8048606_2
    if (*v4 == 0) {
        // 0x804856b
        if (*a2 != 68) {
            // 0x8048600
            // branch -> 0x8048605
            // 0x8048605
            return 0;
        }
        // 0x8048579
        if (*v4 == 0) {
            // 0x8048585
            result = 1;
            // branch -> 0x8048605
        } else {
            // 0x804858c
            result = 0;
            // branch -> 0x8048605
        }
        // 0x8048605
        return result;
    }
    char v5 = *a2; // 0x80485d2
    if (*v4 < 1) {
        // 0x80485cf
        if (v5 == 82) {
            // 0x80485d9
            g4 = v2;
            int32_t v6 = *(int32_t *)(v1 + 4); // 0x80485e6
            result = function_8048539((int32_t *)v6, (char *)(v3 + 1), v2);
            // branch -> 0x8048605
        } else {
            // 0x80485f9
            result = 0;
            // branch -> 0x8048605
        }
        // 0x8048605
        return result;
    }
    // 0x804859f
    if (v5 == 76) {
        // 0x80485a9
        g4 = v2;
        int32_t v7 = *a1; // 0x80485b6
        result = function_8048539((int32_t *)v7, (char *)(v3 + 1), v2);
        // branch -> 0x8048605
    } else {
        // 0x80485c8
        result = 0;
        // branch -> 0x8048605
    }
    // 0x8048605
    return result;
}

// Address range: 0x8048607 - 0x80486a3
int32_t function_8048607(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    int32_t result = v1;
    int32_t v2 = 0x1000000 * a2 / 0x1000000; // 0x8048610_0
    if (a1 != NULL) {
        // 0x804864b
        if ((int32_t)*(char *)(v1 + 8) < v2) {
            int32_t v3 = *(int32_t *)(v1 + 4); // 0x8048665
            *(int32_t *)(result + 4) = function_8048607((int32_t *)v3, v2);
            // branch -> 0x80486a2
        } else {
            // 0x8048682
            *(int32_t *)result = function_8048607((int32_t *)*a1, v2);
            // branch -> 0x80486a2
        }
        // 0x80486a2
        return result;
    }
    char * mem = malloc(12); // 0x804861e
    result = (int32_t)mem;
    *(int32_t *)mem = 0;
    *(int32_t *)(result + 4) = 0;
    *(char *)(result + 8) = (char)v2;
    // branch -> 0x80486a2
    // 0x80486a2
    return result;
}

// Address range: 0x80486a4 - 0x80486ef
void function_80486a4(void) {
    // 0x80486a4
    int32_t v1;
    if (v1 != 0) {
        // 0x80486b0
        function_80486a4();
        printf("%c ", *(char *)(v1 + 8));
        function_80486a4();
        // branch -> 0x80486ee
    }
}

// Address range: 0x80486f0 - 0x804873d
int32_t function_80486f0(int32_t a1) {
    int32_t v1 = a1;
    if (*(char *)a1 == 0) {
        // 0x8048739
        return 0;
    }
    int32_t v2 = 0;
    char v3 = *(char *)(v2 + a1); // 0x804870e
    int32_t result = function_8048607((int32_t *)0, (int32_t)v3); // 0x804871b
    int32_t v4 = v2 + 1; // 0x8048726
    // branch -> 0x8048706
    while (*(char *)(v1 + v4) != 0) {
        // 0x8048706
        v2 = v4;
        v3 = *(char *)(v2 + v1);
        result = function_8048607((int32_t *)result, (int32_t)v3);
        v4 = v2 + 1;
        // continue -> 0x8048706
    }
    // 0x804872a
    // branch -> 0x8048739
    // 0x8048739
    return result;
}

// Address range: 0x804873e - 0x80487ff
int32_t function_804873e(int32_t a1, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v2 = function_80486f0(*(int32_t *)&g6); // 0x804875b
    if (a1 != 3) {
        // 0x804876b
        puts("You have the wrong number of arguments for this forest.");
        printf("%s [password] [string]\n", (char *)*a2);
        exit(1);
        // UNREACHABLE
    }
    int32_t v3 = *(int32_t *)(v1 + 4); // 0x80487a1
    g4 = v3;
    int32_t v4 = *(int32_t *)(v1 + 8); // 0x80487a9
    int32_t v5;
    if (function_804848b(v2, (char *)v4, (char *)v3, v5) == 0) {
        // 0x80487d6
        puts("Nope.");
        // branch -> 0x80487e6
    } else {
        // 0x80487c4
        puts("You did it! Submit the input as the flag");
        // branch -> 0x80487e6
    }
    // 0x80487e6
    return 0;
}

// Address range: 0x8048800 - 0x8048860
int32_t function_8048800(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // edi
    int32_t v2 = function_80483c0(); // 0x8048806
    g2 = a1;
    function_80482f4();
    int32_t v3 = g3; // 0x8048823
    int32_t result = v3 - 248; // 0x8048823
    int32_t v4 = v2 + 0x12e1 - result; // 0x8048829
    g5 = v4 / 4;
    if (v4 < 4) {
        // 0x8048859
        return result;
    }
    // 0x8048838
    g1 = a2;
    ((int32_t (*)(int32_t, int32_t))*(int32_t *)(v3 - 248 + 4 * v1))(a2, a3);
    int32_t v5 = v1 + 1; // 0x8048852
    // branch -> 0x8048838
    while (v5 != g5) {
        // 0x8048838
        // 0x8048838
        g1 = a2;
        ((int32_t (*)(int32_t, int32_t))*(int32_t *)(g3 - 248 + 4 * v5))(a2, a3);
        v5++;
        // branch -> 0x8048838
    }
    // 0x8048859
    return g1;
}

// Address range: 0x8048861 - 0x8048871
void function_8048861(void) {
    // 0x8048861
    return;
}

// Address range: 0x8048874 - 0x8048887
void function_8048874(void) {
    // 0x8048874
    function_80483c0();
}

// --------------- Dynamically Linked Functions ---------------

// void __gmon_start(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// void exit(int status);
// void * malloc(size_t size);
// int printf(const char * restrict format, ...);
// int puts(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.9.2)
// Detected functions: 15
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2017-04-12 15:55:04
